#lang sicp

(#%require rackunit)

(define (=number? exp num)
  (and (number? exp) (= exp num)))
(define (power base exp)
  (* exp (* base (log exp))))

(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (simplify exp)
  (if (null? (cdr exp)) (car exp) exp))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((null? a2) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+ a2))))

(define (split el seq)
  (define (iter before after)
    (cond ((null? after) nil)
          ((eq? (car after) el) (list before (cdr after)))
          (else (iter (append before (list (car after)))
                      (cdr after)))))
  (iter '() seq))

(define (omit-paren exp)
  (if (null? (cdr exp))
      (car exp)
      exp))

(define (sum? exp)
  (and (pair? exp)
       (not (null? (split '+ exp)))))
(define (addend s)
  (omit-paren (car (split '+ s))))
(define (augend s)
  (omit-paren (cadr (split '+ s))))

(define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (list m1 '* m2))))

(define (product? exp)
  (and (pair? exp)
       (not (sum? exp))
       (not (null? (split '* exp)))))
(define (multiplier p)
  (car p))
(define (multiplicand p)
  (simplify (cddr p)))

(define (make-exponention base exp)
  (cond ((=number? exp 0) 1)
        ((=number? exp 1) base)
        ((and (number? exp) (number? base)) (power base exp))
        (else (list base '** exp))))
(define (exponention? exp)
  (and (pair? exp) (eq? (cadr exp) '**)))
(define (base exp)
  (car exp))
(define (exponent exp)
  (caddr exp))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum (make-product (multiplier exp)
                                 (deriv (multiplicand exp) var))
                   (make-product (multiplicand exp)
                                 (deriv (multiplier exp) var))))
        ((exponention? exp)
         (make-product (make-product (exponent exp)
                                     (make-exponention (base exp)
                                                       (- (exponent exp) 1)))
                       (deriv (base exp) var)))
        (else (error "unknown expression type -- DERIV" exp))))


(check-equal? (deriv '(x + 3 + 5 + x) 'x) 2)
(check-equal? (deriv '(x + (3 + x) + x) 'x) 3)
(check-equal? (deriv '(x + 3 * (x + y + 2)) 'x) 4)
(check-equal? (deriv '(x + 3 * x + y + 2 * x + 2) 'x) 6)
;(check-equal? (deriv '(x ** 3 + 2 * x ** 2 + 3 * (x + y + 2)) 'x) '(3 * x ** 2 + 2 * 2 * x + 3))
